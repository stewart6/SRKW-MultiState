
    model {
    
    #--------------------------------------
    # Transition Parameters:
    # G (Growth) probability of increasing 1 BC
    # EG (Extreme Growth) probability of increasing 2 or more BCs
    # D (Decline) probability of decreasing 1 BC
    # ED (Extreme Decline) probability of decreasing 2 or more BCs
    # S (Stable) probability of remaining in the same BC class
    # M (Mortality) probability of dying, specific to each BC 
    
    #--------------------------------------
    # States (S):
    # 6 Dead
    # 1 BC1
    # 2 BC2
    # 3 BC3
    # 4 BC4
    # 5 BC5
    #--------------------------------------
    
    
    # Estimate slope & intercept relationships for G, EG, D, EG (params 2-5)
    # M will be a mean value that does not vary with covariates (param 1)
    # S will be an annual value that does not have a linear relationship with covariates (param 6)
    
    # Slope & Intercept Priors

    for(c in 2:(Params-1)){
    intercept[c] ~ dunif(-20,20)
    slope[c] ~ dunif(-20,20)
    }

    for(c in 2:(Params-1)){

    sigma.e[c] ~ dunif(0,5) #in logit space
    tau.e[c] <- pow(sigma.e[c],-2)
    
    for(t in 1:(n.occasions-1)){  # error term for clogit fit
    e[c,t] ~ dnorm(0,tau.e[c]) # different error distribution for each parameter
    }#t
    }#c    

    
    M.intercept ~ dunif(-20,20)
    sigma.M ~ dunif(0,1) # sigma M is in proportional space (random effect of M[bc] around mean.M) not logit space
    tau.M = pow(sigma.M,-2)    
    

    # Cumulative Logit calculations for covariate fits

    for(t in 1:(n.occasions-1)){
    
    
    log(phi[t,1]) <- M.intercept #M
    prob[t,1] <- phi[t,1] / sum(phi[t, 1:Params])
    
    phi[t,6] <- 1 #S â€” one parameter has to be fixed at 1 for identifiability
    prob[t,6] <- 1 / sum(phi[t, 1:Params])
    
    for(c in 2:(Params-1)){ #six possible transitions (ED,D,S,G,EG,M)
    log(phi[t,c]) <- intercept[c] + slope[c] * cov[t] + e[c,t]
    prob[t,c] <- phi[t,c] / sum(phi[t, 1:Params])
    }#c
    }#t
    
    
    #Calculate M by body condition
    #First simplify the annual Ms to a single mean M (they should all be very similar, anyway)
    mean.M = mean(prob[1:(n.occasions-1),1])
    
    #Then estimate M[bc] as a random effect on the mean M
    for(bc in 1:n.bc){
    M[bc] ~ dnorm(mean.M, tau.M)
    
    #Estimate an annual S for each BC, effectively absorbing the differences in M[bc]
    for(t in 1:(n.occasions-1)){
    S[t,bc] = 1-(G[t]+EG[t]+D[t]+ED[t]+M[bc])
    }#t
    }#bc
    
    for(t in 1:(n.occasions-1)){
    G[t]  = prob[t,2]
    EG[t] = prob[t,3]
    D[t]  = prob[t,4]
    ED[t] = prob[t,5]
    }#t
    

    
    ## Define state-transition and observation matrices ##
    
    # State 6: dead; 1-5: BC 1-5  
    # Define probabilities of state S(t+1) given S(t)
    

    for (t in 1:(n.occasions-1)){
    
    # probability of moving [from, t, to]
    
    #transition matrices for starting BC of 1
    ps[1,t,1] <- S[t,1] + D[t] + ED[t]
    ps[1,t,2] <- G[t]
    ps[1,t,3] <- EG[t]
    ps[1,t,4] <- EG[t]
    ps[1,t,5] <- EG[t]
    ps[1,t,6] <- M[1] #Individual mortality probabilities for each BC
    
    #transition matrices for BC2
    ps[2,t,1] <- D[t] + ED[t]
    ps[2,t,2] <- S[t,2]
    ps[2,t,3] <- G[t]
    ps[2,t,4] <- EG[t]
    ps[2,t,5] <- EG[t]
    ps[2,t,6] <- M[2]
    
    #BC3
    ps[3,t,1] <- ED[t]
    ps[3,t,2] <- D[t]
    ps[3,t,3] <- S[t,3]
    ps[3,t,4] <- G[t]
    ps[3,t,5] <- EG[t]
    ps[3,t,6] <- M[3]
    
    #BC4
    ps[4,t,1] <- ED[t]
    ps[4,t,2] <- ED[t]
    ps[4,t,3] <- D[t]
    ps[4,t,4] <- S[t,4]
    ps[4,t,5] <- G[t] + EG[t]
    ps[4,t,6] <- M[4]
    
    #BC5
    ps[5,t,1] <- ED[t]
    ps[5,t,2] <- ED[t]
    ps[5,t,3] <- ED[t]
    ps[5,t,4] <- D[t]
    ps[5,t,5] <- S[t,5] + G[t] + EG[t]
    ps[5,t,6] <- M[5]
    
    #Dead animals stay dead
    ps[6,t,1] <- 0
    ps[6,t,2] <- 0
    ps[6,t,3] <- 0
    ps[6,t,4] <- 0
    ps[6,t,5] <- 0
    ps[6,t,6] <- 1
    
    } #t1

    
    ## Likelihood ##
    for (i in 1:n.ind){
      for (t in 2:n.occasions){
      # State process: draw S(t) given S(t-1)
        BC[i,t] ~ dcat(ps[BC[i,t-1], t-1,])
    
        log_lik_ind[i,t] <- logdensity.cat(BC[i,t], ps[BC[i,t-1], t-1,]) # log likelihood for LOOIC  / WAIC
        
      } #t1
    log_lik[i] <- sum(log_lik_ind[i,2:n.occasions]) # log likelihood for LOOIC  / WAIC
    }#i
    
    ## Imputation of covariate ##
    # This is necessary as the first covariate value must be NA so it does not 
    # influence the cumulative logit slopes & intercepts (first BCs are dummy values for initialization)
    
    mean.cov ~ dunif(0,100)
    sigma.cov ~ dunif(0,100)
    tau.cov <- pow(sigma.cov,-2)
    
    for (t in 1:(n.occasions-1)){
    cov[t] ~ dnorm(mean.cov,tau.cov)
    }#t
    
    }
    
